#!/usr/bin/env node
import { Command } from "commander";
import color from "picocolors";
import * as clack from "@clack/prompts";
import { log as log$1 } from "@clack/prompts";
import util from "node:util";
import isUnicodeSupported from "is-unicode-supported";
import path from "node:path";
import fs from "node:fs/promises";
import nanoSpawn from "nano-spawn";
import ejs from "ejs";
import { fileURLToPath } from "node:url";
import validateNpmPackage from "validate-npm-package-name";
const isInteractive = ({ stream = process.stdout } = {}) => {
  return Boolean(
    stream && stream.isTTY && process.env["TERM"] !== "dumb" && !("CI" in process.env)
  );
};
const unicode = isUnicodeSupported();
const unicodeWithFallback = (c, fallback) => unicode ? c : fallback;
const SYMBOL_DEBUG = unicodeWithFallback("●", "•");
let verbose = false;
const success = (...messages) => {
  const output = util.format(...messages);
  log$1.success(output);
};
const info = (...messages) => {
  const output = util.format(...messages);
  log$1.info(output);
};
const warn = (...messages) => {
  const output = util.format(...messages);
  log$1.warn(mapLines(output, color.yellow));
};
const error = (...messages) => {
  const output = util.format(...messages);
  log$1.error(mapLines(output, color.red));
};
const log = (...messages) => {
  const output = util.format(...messages);
  log$1.step(output);
};
const debug = (...messages) => {
  if (verbose) {
    const output = util.format(...messages);
    log$1.message(mapLines(output, color.dim), {
      symbol: color.dim(SYMBOL_DEBUG)
    });
  }
};
const setVerbose = (level) => {
  verbose = level;
};
const isVerbose = () => {
  return !isInteractive() || verbose;
};
const logger = {
  success,
  info,
  warn,
  error,
  debug,
  log,
  setVerbose,
  isVerbose
};
function mapLines(text, colorFn) {
  return text.split("\n").map(colorFn).join("\n");
}
const intro = (title) => clack.intro(title);
const outro = (message) => clack.outro(message);
const promptText = async (options) => {
  const result = await clack.text(options);
  if (clack.isCancel(result)) {
    cancelPromptAndExit();
  }
  return result;
};
const promptGroup = async (prompts, options) => {
  const result = await clack.group(prompts, options);
  if (clack.isCancel(result)) {
    cancelPromptAndExit();
  }
  return result;
};
const spinner = (options) => {
  if (logger.isVerbose() || !isInteractive()) {
    return {
      start: (message) => logger.log(formatStartMessage(message)),
      stop: (message, code = 0) => {
        return code === 0 ? logger.log(message) : logger.error(message);
      },
      message: (message) => logger.log(formatStartMessage(message))
    };
  }
  const clackSpinner = clack.spinner(options);
  return {
    start: (message) => {
      clackSpinner.start(message);
    },
    stop: (message, code) => {
      clackSpinner.stop(message, code);
    },
    message: (message) => {
      clackSpinner.message(message);
    }
  };
};
const formatStartMessage = (text) => {
  if (text === void 0) {
    return void 0;
  }
  const messageWithoutDots = text.replace(/\.+$/, "");
  return `${messageWithoutDots}...`;
};
const cancelPromptAndExit = (message) => {
  clack.cancel("Operation cancelled by user.");
  process.exit(0);
};
const name = "rozenite";
const version = "1.0.0-alpha.3";
const description = "Command-line interface for creating and managing React Native DevTools plugins";
const type = "module";
const bin = { "rozenite": "./dist/index.js" };
const files = ["dist", "template"];
const keywords = ["react-native", "devtools", "cli", "plugin", "generator"];
const homepage = "https://github.com/callstackincubator/rozenite#readme";
const bugs = { "url": "https://github.com/callstackincubator/rozenite/issues" };
const repository = { "type": "git", "url": "https://github.com/callstackincubator/rozenite.git" };
const author = "Szymon Chmal <szymon.chmal@callstack.com>";
const license = "MIT";
const dependencies = { "@clack/prompts": "^0.11.0", "commander": "^14.0.0", "ejs": "^3.1.10", "is-unicode-supported": "^2.1.0", "nano-spawn": "^1.0.2", "picocolors": "^1.1.1", "validate-npm-package-name": "^6.0.1" };
const devDependencies = { "@types/ejs": "^3.1.5", "@types/validate-npm-package-name": "^4.0.2" };
const engines = { "node": ">=22" };
const packageJSON$1 = {
  name,
  version,
  description,
  type,
  bin,
  files,
  keywords,
  homepage,
  bugs,
  repository,
  author,
  license,
  dependencies,
  devDependencies,
  engines
};
const getPackageJSON = () => {
  return packageJSON$1;
};
const step = async ({ start, stop, error: error2 }, fn) => {
  const step2 = spinner();
  step2.start(start);
  try {
    await fn();
    step2.stop(stop);
  } catch (err) {
    step2.stop(error2, 1);
    throw err;
  }
};
const createProjectDirectory = async (projectRoot) => {
  await step(
    {
      start: "Creating plugin directory",
      stop: "Plugin directory created",
      error: "Failed to create plugin directory"
    },
    async () => {
      await fs.mkdir(projectRoot, { recursive: true });
    }
  );
};
const spawn = (file, args, options) => {
  const defaultStream = logger.isVerbose() ? "inherit" : "pipe";
  const defaultOptions = {
    stdin: defaultStream,
    stdout: defaultStream,
    // Always 'pipe' stderr to handle errors properly down the line
    stderr: "pipe"
  };
  logger.debug(`Running: ${file}`, ...args ?? []);
  const childProcess = nanoSpawn(file, args, { ...defaultOptions, ...options });
  setupChildProcessCleanup(childProcess);
  return childProcess;
};
const setupChildProcessCleanup = (childProcess) => {
  if (process.stdin.isTTY) {
    process.stdin.setRawMode(false);
  }
  const terminate = async () => {
    try {
      (await childProcess.nodeChildProcess).kill();
      process.exit(1);
    } catch {
    }
  };
  const sigintHandler = () => terminate();
  const sigtermHandler = () => terminate();
  process.on("SIGINT", sigintHandler);
  process.on("SIGTERM", sigtermHandler);
  const cleanup = () => {
    process.off("SIGINT", sigintHandler);
    process.off("SIGTERM", sigtermHandler);
  };
  childProcess.nodeChildProcess.finally(cleanup);
};
const createGitRepository = async (projectRoot) => {
  await step(
    {
      start: "Initializing Git repository",
      stop: "Git repository initialized successfully",
      error: "Failed to initialize Git repository"
    },
    async () => {
      await spawn("git", ["init"], { cwd: projectRoot });
      await spawn("git", ["add", "."], { cwd: projectRoot });
      await spawn("git", ["commit", "-m", "Initial commit"], {
        cwd: projectRoot
      });
    }
  );
};
const renderTemplateFile = async (src, dest, pluginInfo) => {
  let content = await fs.readFile(src, "utf8");
  content = ejs.render(content, pluginInfo);
  let basename = path.basename(dest);
  basename = ejs.render(basename.replace(/^\$/, ""), pluginInfo, {
    openDelimiter: "{",
    closeDelimiter: "}",
    escape: (value) => value.replace(/\./g, path.sep)
  });
  const targetFilePath = path.join(path.dirname(dest), basename);
  const targetDir = path.dirname(targetFilePath);
  await fs.mkdir(targetDir, { recursive: true });
  await fs.writeFile(targetFilePath, content, "utf8");
  const { mode } = await fs.stat(src);
  await fs.chmod(targetFilePath, mode);
};
const renderTemplate = async (src, dest, pluginInfo) => {
  const entries = await fs.readdir(src, { withFileTypes: true });
  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const dstPath = path.join(dest, entry.name);
    if (entry.isDirectory()) {
      await renderTemplate(srcPath, dstPath, pluginInfo);
    } else {
      await renderTemplateFile(srcPath, dstPath, pluginInfo);
    }
  }
};
const TEMPLATE_DIR = fileURLToPath(
  new URL("../template", import.meta.url)
);
const bootstrapPlugin = async (projectRoot, pluginInfo) => {
  await step(
    {
      start: "Bootstrapping plugin",
      stop: "Plugin bootstrapped successfully",
      error: "Failed to bootstrap plugin"
    },
    async () => {
      await renderTemplate(TEMPLATE_DIR, projectRoot, pluginInfo);
    }
  );
};
const getPackageManager = () => {
  const packageManager = process.env.npm_config_user_agent;
  if (packageManager == null ? void 0 : packageManager.startsWith("pnpm")) {
    return "pnpm";
  }
  if (packageManager == null ? void 0 : packageManager.startsWith("yarn")) {
    return "yarn";
  }
  if (packageManager == null ? void 0 : packageManager.startsWith("bun")) {
    return "bun";
  }
  return "npm";
};
const installDependencies = async (projectRoot) => {
  const packageManager = getPackageManager();
  await spawn(packageManager, ["install"], { cwd: projectRoot });
};
const installPackages = async (projectRoot) => {
  await step(
    {
      start: "Installing packages",
      stop: "Packages installed successfully",
      error: "Failed to install packages"
    },
    async () => {
      await installDependencies(projectRoot);
    }
  );
};
const fileExists = async (path2) => {
  try {
    await fs.stat(path2);
    return true;
  } catch {
    return false;
  }
};
const promptForPluginInfo = async () => {
  return await promptGroup({
    name: () => promptText({
      message: "What is the name of the plugin?",
      validate: (input) => {
        if (validateNpmPackage(input).validForNewPackages) {
          return void 0;
        }
        return "The name must be a valid NPM package name";
      }
    }),
    description: () => promptText({
      message: "What is the description of the plugin?",
      validate: (input) => {
        if (input.length > 0) {
          return void 0;
        }
        return "The description must be at least 1 character long";
      }
    })
  });
};
const generateCommand = async (targetDir) => {
  intro("Rozenite");
  const pluginInfo = await promptForPluginInfo();
  const projectRoot = path.resolve(targetDir, pluginInfo.name);
  const projectExists = await fileExists(projectRoot);
  if (projectExists) {
    logger.error(`Directory ${projectRoot} already exists`);
    logger.info(
      "Please choose a different name or remove the existing directory"
    );
    process.exit(1);
  }
  await createProjectDirectory(projectRoot);
  await bootstrapPlugin(projectRoot, pluginInfo);
  await installPackages(projectRoot);
  await createGitRepository(projectRoot);
  logger.success(`Plugin created successfully in ${color.green(projectRoot)}`);
  outro(`Happy hacking!`);
};
const buildCommand = async (targetDir) => {
  intro("Rozenite");
  const hasReactNativeEntryPoint = await fileExists("react-native.ts");
  const hasMetroEntryPoint = await fileExists("background.ts");
  await step(
    {
      start: "Cleaning output directory",
      stop: "Output directory cleaned",
      error: "Failed to clean output directory"
    },
    async () => {
      await fs.rm(path.join(targetDir, "dist"), {
        recursive: true,
        force: true
      });
    }
  );
  await step(
    {
      start: "Building panels",
      stop: "Panels built",
      error: "Failed to build panels"
    },
    async () => {
      await spawn("vite", ["build"], {
        cwd: targetDir
      });
    }
  );
  if (hasMetroEntryPoint) {
    await step(
      {
        start: "Building Metro entry point",
        stop: "Metro entry point built",
        error: "Failed to build Metro entry point"
      },
      async () => {
        await spawn("vite", ["build"], {
          cwd: targetDir,
          env: {
            VITE_ROZENITE_TARGET: "server"
          }
        });
      }
    );
  }
  if (hasReactNativeEntryPoint) {
    await step(
      {
        start: "Building React Native entry point",
        stop: "React Native entry point built",
        error: "Failed to build React Native entry point"
      },
      async () => {
        await spawn("vite", ["build"], {
          cwd: targetDir,
          env: {
            VITE_ROZENITE_TARGET: "react-native"
          }
        });
      }
    );
  }
  outro("Plugin built successfully");
};
const devCommand = async (targetDir) => {
  intro("Rozenite");
  const hasReactNativeEntryPoint = await fileExists("react-native.ts");
  try {
    const processes = [];
    if (hasReactNativeEntryPoint) {
      const rnProcess = spawn("vite", ["build", "--watch"], {
        cwd: targetDir,
        env: {
          VITE_ROZENITE_TARGET: "react-native"
        }
      });
      processes.push(rnProcess);
    }
    const clientProcess = spawn("vite", ["dev"], {
      cwd: targetDir,
      env: {
        VITE_ROZENITE_TARGET: "client"
      }
    });
    processes.push(clientProcess);
    await Promise.all(processes.map((p) => p.nodeChildProcess));
    logger.info("Development servers are running... Press Ctrl+C to stop");
    await new Promise((resolve) => {
      const handleSigInt = () => {
        process.off("SIGINT", handleSigInt);
        resolve();
      };
      process.on("SIGINT", handleSigInt);
    });
  } catch (error2) {
    logger.error("Failed to start development servers:", error2);
    throw error2;
  }
  outro("Development environment stopped");
};
const packageJSON = getPackageJSON();
const main = async () => {
  const program = new Command(packageJSON.name).version(packageJSON.version).description("Create and build React Native DevTools plugins");
  program.command("generate").alias("g").description("Generate a new React Native DevTools plugin").arguments("[path]").usage(`[options] ${color.green("[path]")}`).action(async (path2) => {
    const targetDir = path2 ?? process.cwd();
    await generateCommand(targetDir);
  });
  program.command("build").alias("b").description("Build a React Native DevTools plugin").arguments("[path]").usage(`[options] ${color.green("[path]")}`).action(async (path2) => {
    const targetDir = path2 ?? process.cwd();
    await buildCommand(targetDir);
  });
  program.command("dev").alias("d").description("Start development server with watchers").arguments("[path]").usage(`[options] ${color.green("[path]")}`).action(async (path2) => {
    const targetDir = path2 ?? process.cwd();
    await devCommand(targetDir);
  });
  program.parse(process.argv);
};
main().catch((error2) => {
  logger.error("Command failed");
  logger.error("Error details:", error2);
  outro(
    `If you think this is a bug, please report it at ${packageJSON.bugs.url}`
  );
  process.exit(1);
});
