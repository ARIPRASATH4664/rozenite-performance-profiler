"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const react = require("@vitejs/plugin-react");
const reactNativeWeb = require("vite-plugin-react-native-web");
const process$1 = require("node:process");
const fs = require("node:fs");
const path = require("node:path");
const ejs = require("ejs");
const node_url = require("node:url");
const vite = require("vite");
const fs$1 = require("node:fs/promises");
const maybeDtsPlugin = require("vite-plugin-dts");
const assert = require("node:assert");
var _documentCurrentScript = typeof document !== "undefined" ? document.currentScript : null;
const resolveFileWithExtensions = (directory, baseName) => {
  const extensions = [".tsx", ".ts", ".jsx", ".js"];
  for (const ext of extensions) {
    const filePath = path.join(directory, baseName + ext);
    if (fs.existsSync(filePath)) {
      return filePath;
    }
  }
  return null;
};
const rozeniteServerPlugin = () => {
  return {
    name: "rozenite-server-plugin",
    config(config) {
      var _a;
      const projectRoot = config.root ?? process$1.cwd();
      const backgroundFilePath = resolveFileWithExtensions(
        projectRoot,
        "background"
      );
      if (!backgroundFilePath) {
        throw new Error("Background file not found");
      }
      config.build ?? (config.build = {});
      (_a = config.build).rollupOptions ?? (_a.rollupOptions = {});
      config.build.rollupOptions.input = backgroundFilePath;
      config.build.ssr = true;
      config.build.rollupOptions.output = {
        format: "cjs"
      };
    }
  };
};
const loadConfig = async (configPath) => {
  const absoluteConfigPath = path.resolve(process.cwd(), configPath);
  if (!fs.existsSync(absoluteConfigPath)) {
    throw new Error(`Configuration file not found: ${absoluteConfigPath}`);
  }
  try {
    const configContent = await fs.promises.readFile(
      absoluteConfigPath,
      "utf-8"
    );
    const result = await vite.transformWithEsbuild(
      configContent,
      absoluteConfigPath,
      {
        loader: "ts",
        format: "cjs",
        target: "esnext"
      }
    );
    const moduleExports = {};
    const module2 = { exports: moduleExports };
    const exports2 = moduleExports;
    const moduleFunction = new Function("module", "exports", result.code);
    moduleFunction(module2, exports2);
    const configModule = module2.exports;
    const config = configModule.default || configModule;
    if (!config || typeof config !== "object") {
      throw new Error("Configuration must export an object");
    }
    return config;
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(
        `Failed to load configuration from ${configPath}: ${error.message}`
      );
    }
    throw new Error(`Failed to load configuration from ${configPath}`);
  }
};
const getPackageJSON = async (projectRoot) => {
  const packageJSONPath = path.join(projectRoot, "package.json");
  const packageJSON = await fs$1.readFile(packageJSONPath, "utf8");
  return JSON.parse(packageJSON);
};
const TEMPLATES_DIR = path.resolve(
  node_url.fileURLToPath(typeof document === "undefined" ? require("url").pathToFileURL(__filename).href : _documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === "SCRIPT" && _documentCurrentScript.src || new URL("index.cjs", document.baseURI).href),
  "..",
  "..",
  "templates"
);
const PANELS_DIR = "./panels";
const rozeniteClientPlugin = () => {
  let projectRoot = process$1.cwd();
  let viteServer = null;
  let rozeniteConfig = null;
  const getRozeniteConfig = () => {
    if (!rozeniteConfig) {
      throw new Error("rozenite.config.ts not found");
    }
    return rozeniteConfig;
  };
  const getPanels = () => {
    return getRozeniteConfig().panels.map((entry) => {
      const name = path.basename(entry.source, path.extname(entry.source));
      return {
        name,
        label: entry.name,
        sourceFile: path.resolve(projectRoot, entry.source),
        htmlFile: name + ".html"
      };
    });
  };
  const PANEL_TEMPLATE = path.join(TEMPLATES_DIR, "panel.ejs");
  const generatePanelHtmlContent = (panel) => {
    const template = fs.readFileSync(PANEL_TEMPLATE, "utf-8");
    const relativePath = path.relative(projectRoot, panel.sourceFile);
    return ejs.render(template, {
      panelName: panel.name,
      panelFile: relativePath
    });
  };
  return {
    name: "rozenite-client-plugin",
    async config(config) {
      var _a;
      if (config.root) {
        projectRoot = config.root;
      }
      rozeniteConfig = await loadConfig(
        path.resolve(projectRoot, "rozenite.config.ts")
      );
      const panels = getPanels();
      config.server ?? (config.server = {});
      config.server.open = false;
      config.server.port = 8888;
      config.build ?? (config.build = {});
      (_a = config.build).rollupOptions ?? (_a.rollupOptions = {});
      config.build.rollupOptions.input = {
        ...config.build.rollupOptions.input,
        ...Object.fromEntries(
          panels.map((panel) => [panel.name, panel.htmlFile])
        )
      };
    },
    resolveId(id) {
      const isPanel = getPanels().some((panel) => panel.htmlFile === id);
      if (isPanel) {
        return id;
      }
      return null;
    },
    load(id) {
      const panel = getPanels().find((panel2) => panel2.htmlFile === id);
      if (panel) {
        return generatePanelHtmlContent(panel);
      }
      return null;
    },
    async configureServer(server) {
      viteServer = server;
      const packageJSON = await getPackageJSON(projectRoot);
      server.middlewares.use((req, res, next) => {
        res.setHeader("Access-Control-Allow-Origin", "*");
        res.setHeader(
          "Access-Control-Allow-Methods",
          "GET, POST, PUT, DELETE, OPTIONS"
        );
        res.setHeader(
          "Access-Control-Allow-Headers",
          "Content-Type, Authorization"
        );
        if (req.method === "OPTIONS") {
          res.statusCode = 200;
          res.end();
          return;
        }
        const panels = getPanels();
        const url = req.url || "/";
        if (url === "/rozenite.json") {
          res.setHeader("Content-Type", "application/json");
          res.end(
            JSON.stringify(
              {
                name: packageJSON.name,
                version: packageJSON.version,
                description: packageJSON.description,
                panels: panels.map((panel2) => ({
                  name: panel2.label,
                  source: "/" + panel2.htmlFile
                }))
              },
              null,
              2
            )
          );
          return;
        }
        const panel = panels.find((panel2) => "/" + panel2.htmlFile === url);
        if (panel) {
          const htmlContent = generatePanelHtmlContent(panel);
          server.transformIndexHtml(req.url || "/", htmlContent).then((html) => {
            res.setHeader("Content-Type", "text/html");
            res.end(html);
          }).catch((err) => {
            next(err);
          });
          return;
        }
        next();
      });
    },
    watchChange(id, change) {
      if (change.event !== "create" && change.event !== "delete") {
        return;
      }
      const relativePath = path.relative(projectRoot, id);
      if (!relativePath.startsWith(PANELS_DIR)) {
        return;
      }
      viteServer == null ? void 0 : viteServer.ws.send({
        type: "full-reload",
        path: "/"
      });
    },
    async generateBundle() {
      const panels = getPanels();
      const packageJSON = await getPackageJSON(projectRoot);
      this.emitFile({
        type: "asset",
        fileName: "rozenite.json",
        source: JSON.stringify({
          name: packageJSON.name,
          version: packageJSON.version,
          description: packageJSON.description,
          panels: panels.map((panel) => ({
            name: panel.label,
            source: "/" + panel.htmlFile
          }))
        })
      });
    }
  };
};
const rozeniteReactNativePlugin = () => {
  return {
    name: "rozenite-react-native-plugin",
    config(config) {
      var _a;
      const projectRoot = config.root ?? process.cwd();
      config.build ?? (config.build = {});
      (_a = config.build).rollupOptions ?? (_a.rollupOptions = {});
      config.build.lib = {
        entry: path.resolve(projectRoot, "react-native.ts"),
        formats: ["es", "cjs"],
        fileName: (format) => `react-native.${format === "es" ? "js" : "cjs"}`
      };
      config.build.rollupOptions.external = (id) => {
        if (id.startsWith("node:")) {
          return true;
        }
        return !id.startsWith(".") && !path.isAbsolute(id);
      };
      delete config.build.rollupOptions.input;
    }
  };
};
function requirePlugin() {
  let input = "";
  let inputName = "";
  let isDevMode = false;
  const moduleToChunkMap = /* @__PURE__ */ new Map();
  return {
    name: "vite-require-plugin",
    configResolved(config) {
      isDevMode = config.command === "serve";
    },
    transform(code, id) {
      if (!isDevMode || id !== input) {
        return null;
      }
      let transformedCode = code;
      const imports = [];
      const importMap = /* @__PURE__ */ new Map();
      const requireRegex = /require\s*\(\s*['"`]([^'"`]+)['"`]\s*\)/g;
      let match;
      while ((match = requireRegex.exec(code)) !== null) {
        const moduleName = match[1];
        if (moduleName && !importMap.has(moduleName)) {
          const importName = `__import_${importMap.size}`;
          importMap.set(moduleName, importName);
          imports.push(`import * as ${importName} from '${moduleName}';`);
        }
      }
      transformedCode = transformedCode.replace(
        /require\s*\(\s*['"`]([^'"`]+)['"`]\s*\)/g,
        (match2, moduleName) => {
          const importName = importMap.get(moduleName);
          return importName || match2;
        }
      );
      if (imports.length > 0) {
        transformedCode = imports.join("\n") + "\n" + transformedCode;
      }
      return {
        code: transformedCode,
        map: null
      };
    },
    async buildStart(options) {
      assert(Array.isArray(options.input), "input must be an array");
      assert(
        options.input.length === 1,
        "input must be an array with one entry"
      );
      input = options.input[0];
      inputName = path.basename(input).replace(/\.[^/.]+$/, "");
      const code = fs.readFileSync(input, "utf-8");
      const requires = /* @__PURE__ */ new Set();
      const requireRegex = /require\s*\(\s*['"`]([^'"`]+)['"`]\s*\)/g;
      let match;
      while ((match = requireRegex.exec(code)) !== null) {
        const moduleName = match[1];
        if (moduleName) {
          requires.add(moduleName);
        }
      }
      for (const req of requires) {
        const resolved = await this.resolve(req, input);
        if (resolved) {
          const fileName = path.basename(resolved.id).replace(/\.[^/.]+$/, "") + ".js";
          this.addWatchFile(resolved.id);
          this.emitFile({
            type: "chunk",
            id: resolved.id,
            fileName
          });
          moduleToChunkMap.set(req, fileName);
        }
      }
    },
    renderChunk(code, chunk) {
      if (chunk.name !== inputName) {
        return null;
      }
      let transformedCode = code;
      transformedCode = transformedCode.replace(
        /require\s*\(\s*['"`]([^'"`]+)['"`]\s*\)/g,
        (match, moduleName) => {
          const chunkName = moduleToChunkMap.get(moduleName);
          if (chunkName) {
            return `require('./${chunkName}')`;
          }
          return match;
        }
      );
      return {
        code: transformedCode,
        map: null
      };
    }
  };
}
const dtsPlugin = "default" in maybeDtsPlugin ? maybeDtsPlugin.default : maybeDtsPlugin;
const rozenitePlugin = () => {
  const isServer = process.env.VITE_ROZENITE_TARGET === "server";
  const isReactNative = process.env.VITE_ROZENITE_TARGET === "react-native";
  if (isServer) {
    return [rozeniteServerPlugin()];
  } else if (isReactNative) {
    return [
      react(),
      requirePlugin(),
      rozeniteReactNativePlugin(),
      dtsPlugin({ rollupTypes: true })
    ];
  }
  return [
    react(),
    // @ts-expect-error: TypeScript gets confused by the dual export
    reactNativeWeb(),
    rozeniteClientPlugin()
  ];
};
exports.rozenitePlugin = rozenitePlugin;
